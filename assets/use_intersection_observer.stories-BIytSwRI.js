var f=Object.defineProperty;var h=(r,e,t)=>e in r?f(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var c=(r,e,t)=>h(r,typeof e!="symbol"?e+"":e,t);import{j as l}from"./jsx-runtime-xF634gn_.js";import{e as n}from"./index-C-7etoUd.js";class d{constructor(){c(this,"mapping");c(this,"observer");this.mapping=new Map}init(){return this.observer||(this.observer=new IntersectionObserver(e=>{for(const t of e){const s=this.mapping.get(t.target);s&&s(t.isIntersecting)}})),this.observer}assertObserver(){if(!this.observer)throw new Error("You need to initialize the observer before")}add(e,t){this.assertObserver(),this.mapping.set(e,t),this.observer.observe(e)}destroy(){this.assertObserver(),this.mapping.clear(),this.observer.disconnect()}remove(e){this.assertObserver(),this.mapping.delete(e),this.observer.unobserve(e)}}const a=new d;function v(){const r=n.useRef(null),[e,t]=n.useState(!1);return n.useEffect(()=>()=>{r.current&&a.remove(r.current)},[]),[n.useCallback(o=>{o&&(a.init(),r.current=o,a.add(o,t))},[]),{isIntersecting:e}]}const I={title:"Hooks/useIntersectionObserver",component:v},u=r=>{const{title:e}=r,[t,{isIntersecting:s}]=v();return console.log(`Render Section ${e}`,{isIntersecting:s}),l.jsx("div",{ref:t,style:{height:"20vh",display:"flex",border:"1px dashed #000",fontSize:"2rem"},children:l.jsx("div",{style:{margin:"auto"},children:e})})},i=()=>Array.from({length:5}).map((r,e)=>l.jsx(u,{title:`${e+1}`},`${e+1}`));var p,m,b;i.parameters={...i.parameters,docs:{...(p=i.parameters)==null?void 0:p.docs,source:{originalSource:"() => Array.from({\n  length: 5\n}).map((_, index) => <Section key={`${index + 1}`} title={`${index + 1}`} />)",...(b=(m=i.parameters)==null?void 0:m.docs)==null?void 0:b.source}}};const y=["DemoExample"];export{i as DemoExample,y as __namedExportsOrder,I as default};
